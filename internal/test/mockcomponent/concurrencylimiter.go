// Code generated by MockGen. DO NOT EDIT.
// Source: internal/component/concurrencylimiter/contract.go

// Package mockcomponent is a generated GoMock package.
package mockcomponent

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockConcurrencyLimiter is a mock of ConcurrencyLimiter interface.
type MockConcurrencyLimiter struct {
	ctrl     *gomock.Controller
	recorder *MockConcurrencyLimiterMockRecorder
}

// MockConcurrencyLimiterMockRecorder is the mock recorder for MockConcurrencyLimiter.
type MockConcurrencyLimiterMockRecorder struct {
	mock *MockConcurrencyLimiter
}

// NewMockConcurrencyLimiter creates a new mock instance.
func NewMockConcurrencyLimiter(ctrl *gomock.Controller) *MockConcurrencyLimiter {
	mock := &MockConcurrencyLimiter{ctrl: ctrl}
	mock.recorder = &MockConcurrencyLimiterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConcurrencyLimiter) EXPECT() *MockConcurrencyLimiterMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockConcurrencyLimiter) Run(job func()) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", job)
	ret0, _ := ret[0].(int)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockConcurrencyLimiterMockRecorder) Run(job interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockConcurrencyLimiter)(nil).Run), job)
}

// Wait mocks base method.
func (m *MockConcurrencyLimiter) Wait() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Wait")
}

// Wait indicates an expected call of Wait.
func (mr *MockConcurrencyLimiterMockRecorder) Wait() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Wait", reflect.TypeOf((*MockConcurrencyLimiter)(nil).Wait))
}
